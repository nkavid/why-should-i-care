# What are Google Protocol Buffers and why should I care?

## Non-goals

This will not explain how to use protobuf for complete use-case or real project.

## Intro

From google docs:

> Protocol Buffers (a.k.a., protobuf) are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data.

In `foobar.proto` file declaring a structured message.

```protobuf
syntax = "proto3";

package lorem;

message Baz
{
  int32 someInteger = 1;
  string someString = 2;
}
```

We can generate a C++ implementation of this protobuf message in directory `output`.

```
mkdir output
protoc foobar.proto --cpp_out=output
```

In `main.cpp` creating an instance of a class autogenerated from message declaration.

```cpp
lorem::Baz baz{};

// set_* is just one of several autogenerated methods
baz.set_someinteger(64);
baz.set_somestring("wololo");

// lowercase after 'some'? hmm

// one representation our message as serialized binary
std::string buffer{};
assert(baz.SerializeToString(&buffer));

// display serialized binary as a string in terminal
std::cout << buffer << '\n';
```

Compiling our executable, message implementation, and linking with protobuf library then running our executable.

```
g++ main.cpp output/foobar.pb.cc -lprotobuf
./a.out
```

We get output in terminal

```
@wololo
```

## So?

Just as ez in python

```
mkdir python_output
protoc foobar.proto --python3_out=python_output
```

and just

```python
import python_output.foobar_pb2 as foobar

def main():
  baz = foobar.Baz()
  # where did 'lorem' go? :(
  
  baz.someInteger = 64
  baz.someString = "wawaweewa"
  
  string_buffer = baz.SerializeToString()
  
  print(string_buffer.decode("ascii"))

if __name__ == "__main__":
  main()
```

with output
```
@ wawaweewa
```

(tab in binary code in binary message serialized with python implementation? hmm)

TODO send/receive binary messages and demo structured accessors in different languages of the same messages with uds or shmem or something.

See [shmem/reader.hpp](https://github.com/nkavid/sandbox-gfx/blob/main/gfx/shmem/reader.hpp) and [shmem/writer.hpp](https://github.com/nkavid/sandbox-gfx/blob/main/gfx/shmem/writer.hpp) as examples of shmem utility classes that can be used to read and write from the same Shared Memory resource. [test/shmem_test.cpp](https://github.com/nkavid/sandbox-gfx/blob/main/gfx/test/shmem_test.cpp) with example usage. The `void*` typed parameter may be an binary message whose structured interface is generated by protobuf autogenerator.

```cpp
// composition of different utilities

class LoremBazTransmitter
{
  public:
    // [...]

  private:
    shmem::Writer _writer{"lorem_baz", size};  // method of transmission
    lorem::Baz _baz{};                         // structured message
};
```

See [Beej's Guide to Network Programming](https://beej.us/guide/bgnet/) and [Beej's Guide to UNIX IPC](https://beej.us/guide/bgipc/) for nice guides on Inter-process Communication.

## No validation? No nested messages?

... and when should you use Arena Allocation?

Go read [the actual docs](https://github.com/protocolbuffers/protobuf). Build a thing. Do it.
